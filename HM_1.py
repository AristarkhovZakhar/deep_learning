# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1INdDvDA1_dfZzm2dwcwcXMfcGLhTwQKE
"""

import pandas as pd
import numpy as np

all_data = pd.read_csv('FHM_baze/forest_dataset.csv')
all_data.head(15)

all_data.shape

labels = all_data[all_data.columns[-1]].values
labels

feature_matrix = all_data[all_data.columns[0:-1]].values
feature_matrix

from sklearn.model_selection import train_test_split

train_feature_matrix, test_feature_matrix, train_labels, test_labels = train_test_split(feature_matrix, labels, test_size = 0.2, random_state = 42)

from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

clf = KNeighborsClassifier(1)
clf.fit(train_feature_matrix, train_labels)
y_pred = clf.predict(test_feature_matrix)
accuracy_score(y_pred, test_labels)

"""-  Переберите по сетке от 1 до 10 параметр числа соседей

-  Также вы попробуйте использоввать различные метрики: ['manhattan', 'euclidean']

-  Попробуйте использовать различные стратегии вычисления весов: [‘uniform’, ‘distance’]
"""

from sklearn.model_selection import GridSearchCV

cl = KNeighborsClassifier()
params = { 'n_neighbors': np.arange(1,10),
           'metric': ['manhattan', 'euclidean'],
           'weights': ['uniform', 'distance']
         }

cl_grid = GridSearchCV(cl, params, n_jobs =-1, cv =5, refit=True, scoring='accuracy')

cl_grid.fit(feature_matrix, labels)

cl_grid.best_params_

clf_best = KNeighborsClassifier(n_neighbors= 4, weights = 'distance', metric = 'manhattan')
clf_best.fit(train_feature_matrix, train_labels)
best_prob = clf_best.predict(test_feature_matrix)
probe = accuracy_score(test_labels, best_prob)
print(probe)

optimal_clf = KNeighborsClassifier(4, weights='distance', metric='manhattan')
optimal_clf.fit(train_feature_matrix, train_labels)
pred_prob = optimal_clf.predict_proba(test_feature_matrix)

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np
unique, freq = np.unique(test_labels, return_counts = True)
freq = list(map(lambda x:x/len(test_labels),freq))
pred_freq = pred_prob.mean(axis = 0)
plt.bar(range(1,8),pred_freq, width=0.4, align = 'edge',label='predict')
plt.bar(range(1,8),freq, width=-0.4, align='edge', label='real')
plt.ylim(0, 0.54)
plt.legend()
plt.show()

pred_freq[3]
